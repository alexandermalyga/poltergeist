- case: decorator_single_error
  main: |
    from poltergeist import catch, Result

    @catch(ValueError)
    def test(a: int, b: str) -> float | None: ...

    reveal_type(test)  # N: Revealed type is "def (a: builtins.int, b: builtins.str) -> Union[poltergeist.result.Ok[Union[builtins.float, None]], poltergeist.result.Err[builtins.ValueError]]"

- case: decorator_multiple_errors
  skip: True  # TODO: Enable this test once MyPy properly detects the return type
  main: |
    from poltergeist import catch, Result

    @catch(ValueError, TypeError)
    def test(a: int, b: str) -> float | None: ...

    reveal_type(test)  # N: Revealed type is "def (a: builtins.int, b: builtins.str) -> Union[poltergeist.result.Ok[Union[builtins.float, None]], poltergeist.result.Err[Union[builtins.ValueError, builtins.TypeError]]]"

- case: decorator_invalid_error_type
  main: |
    from poltergeist import catch, Result

    @catch(123)
    def test(a: int, b: str) -> float | None: ...
  out: |
    main:3: error: Argument 1 to "catch" has incompatible type "int"; expected "type[<nothing>]"  [arg-type]
